datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "rhel-openssl-3.0.x"]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expiresAt    DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sessionToken])
}

model User {
  id                      String             @id @default(cuid())
  name                    String?
  email                   String?            @unique
  phone                   String?            @unique
  password                String
  emailVerified           DateTime?
  phoneVerified           DateTime?
  documentsVerified       DateTime? // Дата подтверждения документов
  documentsVerifiedBy     String? // ID администратора, подтвердившего документы
  documentsRejectedAt     DateTime? // Дата отклонения документов
  documentsRejectedReason String? // Причина отклонения документов
  image                   String?
  roleId                  String
  language                String             @default("Russian")
  currency                String             @default("RUB")
  country                 String             @default("russia")
  status                  String             @default("active") // XState workflow: active, suspended, blocked, deleted
  isActive                Boolean            @default(true) // Legacy field, kept for compatibility
  lastSeen                DateTime?
  telegramChatId          String? // Telegram chat ID для отправки уведомлений через бота
  role                    Role               @relation(fields: [roleId], references: [id])
  accounts                Account[]
  sessions                Session[]
  sentMessages            Message[]          @relation("MessageSender")
  user1Rooms              ChatRoom[]         @relation("User1Rooms")
  user2Rooms              ChatRoom[]         @relation("User2Rooms")
  notifications           Notification[]
  blocks                  UserBlock[]
  verificationCodes       VerificationCode[]
  ownedAccounts           UserAccount[]      @relation("OwnedAccounts")
  ownedAccountsByOwner    UserAccount[]     @relation("OwnedAccountsByOwner")
  managedAccounts         AccountManager[]   @relation("ManagedAccounts")
  accountTransfers        AccountTransfer[] @relation("AccountTransfers")
  createdAt               DateTime           @default(now())
  updatedAt               DateTime           @updatedAt
  // Constraint: хотя бы email или phone должен быть заполнен (проверяется на уровне приложения)

  @@index([email])
  @@index([phone])
  @@index([telegramChatId])
  @@index([documentsVerified])
  @@index([status])
}

model Role {
  id          String   @id @default(cuid())
  code        String   @unique // Immutable code: 'SUPERADMIN', 'ADMIN', 'USER'
  name        String   @unique // Display name (can be renamed)
  description String?
  permissions String?  @default("{}") // JSON: {"module": ["action1", "action2"]}
  level       Int      @default(100) // Hierarchy level (0 = highest priority)
  isSystem    Boolean  @default(false) // System role (cannot be deleted)
  users       User[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model VerificationCode {
  id          String   @id @default(cuid())
  identifier  String // email или phone
  code        String // код верификации (6-значный для SMS, токен для email)
  type        String // 'email' | 'phone'
  expires     DateTime
  attempts    Int      @default(0)
  maxAttempts Int      @default(3)
  verified    Boolean  @default(false)
  userId      String?
  user        User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([identifier, type])
  @@index([code])
  @@index([userId])
  @@index([type, verified])
  @@index([expires])
}

model Language {
  id        String   @id @default(cuid())
  name      String   @unique
  code      String   @unique
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Country {
  id        String   @id @default(cuid())
  name      String   @unique
  code      String   @unique
  isActive  Boolean  @default(true)
  states    State[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Currency {
  id        String   @id @default(cuid())
  name      String   @unique
  code      String   @unique
  symbol    String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model State {
  id        String   @id @default(cuid())
  name      String
  code      String
  countryId String?
  country   Country? @relation(fields: [countryId], references: [id], onDelete: Cascade)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  cities City[]

  @@unique([name, id])
}

model City {
  id        String   @id @default(cuid())
  name      String
  code      String
  stateId   String?
  state     State?   @relation(fields: [stateId], references: [id], onDelete: Cascade)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  districts District[]

  @@unique([name, id])
}

model District {
  id        String   @id @default(cuid())
  name      String
  code      String
  cityId    String?
  city      City?    @relation(fields: [cityId], references: [id], onDelete: Cascade)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, id])
}

model Translation {
  id        String   @id @default(cuid())
  key       String // e.g., "navigation.dashboards"
  language  String // e.g., "en", "fr", "ar"
  value     String // The translated text
  namespace String   @default("common") // e.g., "navigation", "common", "forms"
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([key, language, namespace])
}

model EmailTemplate {
  id        String   @id @default(cuid())
  name      String   @unique
  subject   String
  content   String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ChatRoom {
  id        String    @id @default(cuid())
  user1Id   String
  user2Id   String
  user1     User      @relation("User1Rooms", fields: [user1Id], references: [id], onDelete: Cascade)
  user2     User      @relation("User2Rooms", fields: [user2Id], references: [id], onDelete: Cascade)
  messages  Message[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@unique([user1Id, user2Id])
}

model Message {
  id        String    @id @default(cuid())
  content   String
  senderId  String
  sender    User      @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  roomId    String
  room      ChatRoom  @relation(fields: [roomId], references: [id], onDelete: Cascade)
  readAt    DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([createdAt])
}

model Notification {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  title       String
  message     String
  type        String    @default("system") // system, chat, email, etc.
  status      String    @default("unread") // unread, read, archived, deleted
  readAt      DateTime?
  metadata    String?   @default("{}")
  avatarImage String?
  avatarIcon  String?
  avatarText  String?
  avatarColor String?
  avatarSkin  String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId, status, createdAt])
}

model RateLimit {
  id           String    @id @default(cuid())
  key          String // IP или userId
  module       String // 'chat', 'ads', 'upload', 'auth'
  count        Int       @default(0)
  windowStart  DateTime  @default(now())
  windowEnd    DateTime
  blockedUntil DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@unique([key, module, windowStart])
}

model RateLimitConfig {
  id                 String   @id @default(cuid())
  module             String   @unique // 'chat', 'ads', 'upload', 'auth'
  maxRequests        Int // Максимум запросов
  windowMs           Int // Окно в миллисекундах
  blockMs            Int // Блокировка в миллисекундах
  warnThreshold      Int?     @default(0)
  isActive           Boolean  @default(true)
  mode               String   @default("enforce")
  storeEmailInEvents Boolean  @default(true)
  storeIpInEvents    Boolean  @default(true)
  isFallback         Boolean  @default(false)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
}

model RateLimitState {
  id           String    @id @default(cuid())
  key          String // IP или userId
  module       String // 'chat', 'ads', 'upload', 'auth'
  count        Int       @default(0) // Текущее количество запросов в окне
  windowStart  DateTime  @default(now()) // Начало текущего окна
  windowEnd    DateTime // Конец текущего окна
  blockedUntil DateTime? // Время окончания блокировки (если заблокирован)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@unique([key, module])
  @@index([module, updatedAt])
  @@index([blockedUntil])
  @@index([module, blockedUntil])
}

model UserBlock {
  id          String    @id @default(cuid())
  userId      String?
  user        User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
  ipAddress   String? // IP адрес для блокировки неавторизованных пользователей
  ipHash      String?
  ipPrefix    String?
  hashVersion Int       @default(1)
  email       String?
  emailHash   String?
  mailDomain  String?
  reason      String // 'spam', 'abuse', 'rate_limit_violation', etc.
  module      String // 'chat', 'auth', 'registration', 'ads', etc.
  blockedBy   String // ID администратора, который заблокировал
  blockedAt   DateTime  @default(now())
  unblockedAt DateTime? // Время разблокировки (null = permanent)
  isActive    Boolean   @default(true)
  notes       String? // Дополнительные заметки администратора
  cidr        String?
  asn         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Индексы для быстрого поиска
  @@index([userId])
  @@index([ipAddress])
  @@index([ipHash])
  @@index([ipPrefix])
  @@index([emailHash])
  @@index([mailDomain])
  @@index([module])
  @@index([isActive])
  @@index([module, isActive])
  @@index([unblockedAt])
  @@index([asn])
}

model CronJobStatus {
  id            String    @id @default(cuid())
  name          String    @unique
  lastRunAt     DateTime?
  lastSuccessAt DateTime?
  lastResult    String?
  lastCount     Int?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model RateLimitEvent {
  id           String    @id @default(cuid())
  module       String
  key          String
  userId       String?
  ipAddress    String?
  ipHash       String?
  ipPrefix     String?
  hashVersion  Int       @default(1)
  email        String?
  emailHash    String?
  debugEmail   String? // For superadmin debugging only
  eventType    String // 'warning' | 'block'
  mode         String    @default("enforce") // 'monitor' | 'enforce'
  count        Int
  maxRequests  Int
  windowStart  DateTime
  windowEnd    DateTime
  blockedUntil DateTime?
  createdAt    DateTime  @default(now())

  @@index([module, eventType, createdAt])
  @@index([module, key, eventType, mode, windowStart])
  @@index([key, module])
  @@index([userId, module])
  @@index([module])
  @@index([eventType])
  @@index([mode])
  @@index([key])
  @@index([ipHash])
  @@index([ipPrefix])
  @@index([emailHash])
}

model Event {
  id            String   @id @default(cuid())
  source        String
  module        String
  type          String
  severity      String
  actorType     String?
  actorId       String?
  subjectType   String?
  subjectId     String?
  key           String?
  message       String
  payload       String   @default("{}")
  correlationId String?
  metadata      String?  @default("{}")
  createdAt     DateTime @default(now())

  @@index([source, createdAt])
  @@index([module, type, createdAt])
  @@index([key])
  @@index([actorType, actorId])
  @@index([subjectType, subjectId])
}

model TestConfig {
  id        String   @id @default(cuid())
  testId    String   @unique // Corresponds to PlaywrightTestScript.id
  timeout   Int      @default(30000) // Timeout in milliseconds
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([testId])
  @@index([isActive])
}

model NotificationScenario {
  id          String   @id @default(cuid())
  name        String
  description String?
  enabled     Boolean  @default(true)
  trigger     String   @default("{}") // Event trigger config: JSON string { source, type, module?, conditions? }
  actions     String   @default("[]") // Array of actions: JSON string [{ channel, templateId?, content?, delay?, conditions? }]
  conditions  String? // Optional global conditions: JSON string { userRole?, userStatus?, custom? }
  priority    Int      @default(0) // Higher priority scenarios execute first
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?

  executions NotificationExecution[]

  @@index([enabled])
  @@index([priority])
  @@index([createdAt])
}

model NotificationExecution {
  id          String               @id @default(cuid())
  scenarioId  String
  scenario    NotificationScenario @relation(fields: [scenarioId], references: [id], onDelete: Cascade)
  eventId     String? // Reference to Event.id
  status      String // 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled'
  result      String? // Execution result: JSON string { success, messageId, channel, etc. }
  error       String? // Error message if failed
  attempts    Int                  @default(0)
  maxAttempts Int                  @default(3)
  scheduledAt DateTime? // When to execute (for delayed actions)
  createdAt   DateTime             @default(now())
  startedAt   DateTime?
  completedAt DateTime?

  @@index([scenarioId])
  @@index([status])
  @@index([createdAt])
  @@index([scheduledAt])
  @@index([eventId])
}

model DataSanitizationLog {
  id           String   @id @default(cuid())
  operationId  String   @unique // Уникальный ID операции
  target       String // JSON с целью очистки
  options      String // JSON с опциями
  result       String // JSON с результатами
  requestedBy  String? // Кто запросил операцию
  ipAddress    String? // IP адрес инициатора
  userAgent    String? // User agent
  duration     Int // Время выполнения в ms
  success      Boolean  @default(true)
  errorMessage String? // Сообщение об ошибке если была
  createdAt    DateTime @default(now())

  @@index([operationId])
  @@index([requestedBy])
  @@index([createdAt])
  @@index([success])
}

model RegistrationSettings {
  id                       String   @id @default(cuid())
  registrationMode         String   @default("email_or_phone") // 'email_or_phone' | 'email_and_phone'
  requirePhoneVerification Boolean  @default(true) // Всегда true для полного доступа
  requireEmailVerification Boolean  @default(true) // Всегда true при регистрации по email
  smsProvider              String   @default("smsru") // SMS провайдер
  updatedBy                String? // ID администратора, который обновил настройки
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt

  @@unique([id]) // Только одна запись настроек
}

// ========================================
// Service Configuration - External Services
// ========================================

model ServiceConfiguration {
  id          String        @id @default(cuid())
  name        String        @unique // Уникальный код: 'redis', 'prometheus', 'loki', 'grafana', 'sentry'
  displayName String // Отображаемое имя: "Redis Server", "Prometheus"
  type        String // ServiceType: REDIS, POSTGRESQL, PROMETHEUS, LOKI, GRAFANA, SENTRY, SMTP, S3, ELASTICSEARCH
  host        String // Хост сервера
  port        Int? // Порт (опционально)
  protocol    String? // Протокол: redis://, https://, http://
  basePath    String? // Базовый путь API: /api/v1

  // Аутентификация (зашифровано AES-256-GCM)
  username  String? // Имя пользователя
  password  String? // Пароль (зашифровано)
  token     String? // API токен (зашифровано)
  tlsEnabled Boolean @default(false) // Использовать TLS
  tlsCert   String? // Сертификат TLS (зашифровано)

  // Статус подключения
  enabled   Boolean   @default(true) // Активен ли сервис
  status    String    @default("UNKNOWN") // ServiceStatus: CONNECTED, DISCONNECTED, ERROR, UNKNOWN
  lastCheck DateTime? // Последняя проверка подключения
  lastError String? // Последняя ошибка

  // Дополнительные настройки
  metadata  String? @default("{}") // JSON с дополнительными настройками
  createdBy String? // ID администратора, создавшего конфигурацию
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
  @@index([enabled])
  @@index([status])
  @@map("service_configurations")
}

// ========================================
// Workflow & Rules Engine
// ========================================

model WorkflowInstance {
  id        String   @id @default(cuid())
  type      String   // 'listing', 'user', 'company', 'verification'
  entityId  String   // ID сущности
  state     String   // Текущее состояние
  context   String?  @default("{}") // Контекст машины (JSON)
  version   Int      @default(1) // Для optimistic locking
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  transitions WorkflowTransition[]

  @@unique([type, entityId])
  @@index([type, state])
  @@index([updatedAt])
  @@map("workflow_instances")
}

model WorkflowTransition {
  id         String   @id @default(cuid())
  instanceId String
  fromState  String
  toState    String
  event      String   // Событие, вызвавшее переход
  actorId    String?  // Кто инициировал
  actorType  String?  // 'user', 'system', 'cron'
  metadata   String?  @default("{}") // JSON с дополнительными данными
  createdAt  DateTime @default(now())

  instance WorkflowInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  @@index([instanceId])
  @@index([createdAt])
  @@index([event])
  @@index([actorId])
  @@map("workflow_transitions")
}

model BusinessRule {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  category    String   // 'tariff', 'limit', 'blocking', 'notification', 'discount'
  conditions  String   // JSON: { all: [...], any: [...] }
  event       String   // JSON: { type: '...', params: {...} }
  priority    Int      @default(0)
  enabled     Boolean  @default(true)
  createdBy   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  executions RuleExecution[]

  @@index([category, enabled])
  @@index([priority])
  @@index([enabled])
  @@map("business_rules")
}

model RuleExecution {
  id        String   @id @default(cuid())
  ruleId    String
  facts     String   // JSON: входные данные
  result    String   // JSON: результат (events)
  success   Boolean  @default(true)
  duration  Int      // ms
  error     String?
  actorId   String?
  createdAt DateTime @default(now())

  rule BusinessRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@index([ruleId])
  @@index([createdAt])
  @@index([success])
  @@map("rule_executions")
}

// ========================================
// Listings (Доска объявлений)
// ========================================

model Listing {
  id              String    @id @default(cuid())
  title           String
  description     String
  price           Float?
  currency        String    @default("RUB")
  categoryId      String?
  status          String    @default("draft") // Управляется через XState: draft, pending, active, rejected, sold, archived, deleted
  ownerId         String    // ID владельца (User.id)
  moderatorId     String?   // ID модератора
  moderatedAt     DateTime?
  rejectionReason String?
  images          String?   @default("[]") // JSON массив URL
  location        String?
  contacts        String?   @default("{}") // JSON: { phone, email, telegram }
  metadata        String?   @default("{}") // JSON: дополнительные поля
  viewsCount      Int       @default(0)
  publishedAt     DateTime?
  soldAt          DateTime?
  archivedAt      DateTime?
  expiresAt       DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  category ListingCategory? @relation(fields: [categoryId], references: [id])

  @@index([ownerId])
  @@index([status])
  @@index([categoryId])
  @@index([status, createdAt])
  @@index([ownerId, status])
  @@map("listings")
}

model ListingCategory {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  description String?
  parentId    String?  // Для иерархии
  icon        String?
  sortOrder   Int      @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  parent   ListingCategory?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children ListingCategory[] @relation("CategoryHierarchy")
  listings Listing[]

  @@index([parentId])
  @@index([isActive, sortOrder])
  @@map("listing_categories")
}

// ========================================
// User Accounts System
// ========================================

model TariffPlan {
  id          String   @id @default(cuid())
  code        String   @unique // 'FREE', 'BASIC', 'PRO', 'ENTERPRISE'
  name        String   @unique // Отображаемое имя
  description String?
  price       Float    @default(0) // Месячная стоимость
  currency    String   @default("RUB")
  features    String   @default("{}") // JSON с возможностями
  maxAccounts Int?     // Максимум аккаунтов (для NETWORK)
  isActive    Boolean  @default(true)
  isSystem    Boolean  @default(false) // Системный тариф (нельзя удалить)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  accounts    UserAccount[]
  
  @@index([code])
  @@index([isActive])
  @@map("tariff_plans")
}

model UserAccount {
  id          String   @id @default(cuid())
  userId      String   // Владелец аккаунта
  ownerId     String   // Основной владелец (для переданных аккаунтов)
  type        String   // 'LISTING', 'COMPANY', 'NETWORK'
  name        String   // Название аккаунта
  description String?
  tariffPlanId String
  tariffPlan  TariffPlan @relation(fields: [tariffPlanId], references: [id])
  user        User     @relation("OwnedAccounts", fields: [userId], references: [id], onDelete: Cascade)
  owner       User     @relation("OwnedAccountsByOwner", fields: [ownerId], references: [id])
  status      String   @default("active") // 'active', 'suspended', 'archived'
  metadata    String?  @default("{}") // JSON: дополнительные данные
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  managers    AccountManager[]
  transfers   AccountTransfer[] @relation("TransferFrom")
  
  @@index([userId])
  @@index([ownerId])
  @@index([type])
  @@index([status])
  @@index([tariffPlanId])
  @@map("user_accounts")
}

model AccountManager {
  id        String   @id @default(cuid())
  accountId String
  userId    String   // Назначенный пользователь
  account   UserAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  user      User     @relation("ManagedAccounts", fields: [userId], references: [id], onDelete: Cascade)
  canManage Boolean  @default(true) // Может ли управлять
  canEdit   Boolean  @default(true) // Может ли редактировать
  canDelete Boolean  @default(false) // Может ли удалять
  assignedAt DateTime @default(now())
  assignedBy String   // Кто назначил
  revokedAt  DateTime?
  revokedBy  String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  @@unique([accountId, userId])
  @@index([userId])
  @@index([accountId])
  @@index([canManage])
  @@map("account_managers")
}

model AccountTransfer {
  id          String   @id @default(cuid())
  fromAccountId String
  toUserId    String   // Кому передается
  fromAccount UserAccount @relation("TransferFrom", fields: [fromAccountId], references: [id], onDelete: Cascade)
  toUser      User     @relation("AccountTransfers", fields: [toUserId], references: [id], onDelete: Cascade)
  status      String   @default("pending") // 'pending', 'accepted', 'rejected', 'cancelled'
  requestedBy String   // Кто запросил передачу
  acceptedAt  DateTime?
  rejectedAt  DateTime?
  cancelledAt DateTime?
  reason      String?  // Причина отклонения/отмены
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([fromAccountId])
  @@index([toUserId])
  @@index([status])
  @@map("account_transfers")
}
