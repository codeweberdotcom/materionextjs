# Функциональные требования модуля Socket

## Обзор

Модуль Socket обеспечивает реальное время коммуникацию между клиентом и сервером для модулей notifications и chat. Он использует Socket.IO для двусторонней связи.

> ℹ️ Подробнее о клиентских настройках и переменных окружения см. в разделе [Конфигурация клиентского Socket.IO](configuration/socket-client.md).

## Текущая реализация

### useSocket Hook
- Подключение к серверу Socket.IO на localhost:3000
- Автоматическое присоединение пользователя при подключении
- Обработка событий connect/disconnect

### Архитектура
- Клиент: React hooks (useSocket, useChat, useNotifications)
- Сервер: Socket.IO сервер (не найден в коде, предполагается отдельный сервис)
- Протокол: WebSocket с fallback на polling

## Функциональные требования

### Модуль Notifications к Socket

#### NF-1: Получение новых уведомлений в реальном времени
- **Описание**: Модуль notifications должен получать новые уведомления через socket без необходимости перезагрузки страницы
- **Интеграция с useNotifications hook**:
  - Hook подписывается на событие `new-notification` при подключении socket
  - Новые уведомления добавляются в начало массива notifications
  - Автоматическое обновление счетчика непрочитанных уведомлений
- **События**:
  - `new-notification`: отправляется сервером при создании нового уведомления
  - `notification-update`: отправляется при изменении статуса уведомления (прочитано/не прочитано)
- **Требования к данным**:
  - id: string (уникальный идентификатор)
  - title: string (заголовок уведомления)
  - message: string (текст уведомления)
  - type: string (тип уведомления)
  - status: string (статус: 'read' | 'unread')
  - createdAt: string (дата создания в ISO формате)
  - updatedAt: string (дата обновления в ISO формате)
  - userId: string (ID получателя)
  - avatarImage?: string (опциональное изображение аватара)
  - avatarIcon?: string (опциональная иконка аватара)
  - avatarText?: string (опциональный текст аватара)
  - avatarColor?: string (опциональный цвет аватара)
  - avatarSkin?: string (опциональный скин аватара)

#### NF-2: Обновление статуса уведомлений
- **Описание**: Возможность пометить уведомление как прочитанное/не прочитанное через socket
- **Интеграция с useNotifications hook**:
  - Метод `markAsRead(notificationId, read)` обновляет локальное состояние
  - Отправляет PATCH запрос на `/api/notifications/${notificationId}`
  - При успехе обновляет статус в массиве notifications
- **События**:
  - Клиент отправляет: обновление статуса через API
  - Сервер рассылает: `notification-update` всем подключенным клиентам пользователя
- **Требования к данным для notification-update**:
  - id: string (ID уведомления)
  - read: boolean (статус прочтения)

#### NF-3: Удаление уведомлений
- **Описание**: Удаление уведомлений с синхронизацией через socket
- **Интеграция с useNotifications hook**:
  - Метод `removeNotification(notificationId)` удаляет уведомление локально
  - Отправляет DELETE запрос на `/api/notifications/${notificationId}`
  - При успехе удаляет уведомление из массива notifications
- **События**:
  - Клиент: удаление через API
  - Сервер: уведомление о удалении (если требуется)

#### NF-4: Очистка всех уведомлений
- **Описание**: Массовое удаление всех уведомлений
- **Интеграция с useNotifications hook**:
  - Метод `clearAllNotifications()` отправляет DELETE на `/api/notifications/clear-all`
  - Добавляет ID всех уведомлений в localStorage (clearedNotifications)
  - Очищает массив notifications (оставляет только виртуальные)
- **События**: API-based, socket синхронизация опциональна

#### NF-5: Виртуальные уведомления о чате
- **Описание**: Отображение количества непрочитанных чат-сообщений как уведомления
- **Интеграция с useNotifications hook**:
  - Создает виртуальное уведомление `virtual-chat-unread` когда unreadCount > 0
  - Использует данные из useUnreadMessages hook
  - Обновляется автоматически при изменении количества непрочитанных сообщений
- **Особенности**:
  - Не сохраняется в базе данных
  - Имеет специальный ID для идентификации
  - Использует иконку чата и зеленый цвет

#### NF-6: Управление очищенными уведомлениями
- **Описание**: Локальное хранение списка очищенных уведомлений для сессии
- **Интеграция с useNotifications hook**:
  - `getClearedNotifications(userId)`: получение из localStorage
  - `setClearedNotifications(userId, clearedIds)`: сохранение в localStorage
  - `clearUserClearedNotifications(userId)`: очистка при logout
- **Фильтрация**: Исключает очищенные уведомления из отображаемого списка

### Модуль Chat к Socket

#### CF-1: Создание/получение комнаты чата
- **Описание**: Получение или создание комнаты для общения между двумя пользователями
- **События**:
  - `getOrCreateRoom`: клиент запрашивает комнату
  - `roomData`: сервер возвращает данные комнаты и историю сообщений
- **Требования к данным**:
  - room: { id: string, user1Id: string, user2Id: string }
  - messages: массив сообщений с историей

#### CF-2: Отправка сообщений
- **Описание**: Отправка текстовых сообщений в реальном времени
- **События**:
  - `sendMessage`: клиент отправляет сообщение
  - `receiveMessage`: сервер рассылает сообщение получателю
- **Требования к данным**:
  - roomId: string (ID комнаты)
  - message: string (текст сообщения)
  - senderId: string (ID отправителя)
- **Ограничения**:
  - Rate limiting: проверка перед отправкой
  - Максимальная длина сообщения (не определена)

#### CF-3: Получение сообщений в реальном времени
- **Описание**: Автоматическое получение новых сообщений без перезагрузки
- **События**: `receiveMessage`
- **Требования к данным**: см. CF-2

#### CF-4: Отметка сообщений как прочитанные
- **Описание**: Отметка сообщений как прочитанные при просмотре
- **События**:
  - `markMessagesRead`: клиент отмечает сообщения как прочитанные
  - `messagesRead`: сервер подтверждает прочтение
- **Требования к данным**:
  - roomId: string
  - userId: string (ID пользователя, который прочитал)
  - count: number (количество прочитанных сообщений)

#### CF-5: Rate Limiting для сообщений
- **Описание**: Ограничение частоты отправки сообщений (активно)
- **События**:
  - `rateLimitExceeded`: сервер сообщает о превышении лимита
  - `rateLimitWarning`: сервер предупреждает о приближении лимита
- **Требования к данным (новый контракт)**:
  - `blockedUntilMs`: number (timestamp мс окончания блокировки)
  - `retryAfterSec`: number (секунды до следующей попытки)
  - `remaining?`: number (оставшиеся попытки)
  - **Legacy**: `blockedUntil`, `retryAfter` (для совместимости клиентов)

#### CF-5.1: Rate Limiting для комнат, read, ping (подготовлено)
- **Описание**: Мягкие лимиты для `getOrCreateRoom`, `markMessagesRead`, `ping` подготовлены, но **не активированы**. Включаются через отдельные модули `chat-rooms`, `chat-read`, `chat-ping` (фабрика `createSocketRateLimiter`), с тем же форматом данных, что и выше.

#### CF-6: Управление непрочитанными сообщениями
- **Описание**: Подсчет и отображение количества непрочитанных сообщений
- **Интеграция**: с useUnreadMessages hook
- **Обновление**: при получении новых сообщений и отметке как прочитанные

## Общие требования

### OS-1: Управление подключением
- **Описание**: Автоматическое подключение/переподключение к socket серверу
- **События**:
  - `connect`: успешное подключение
  - `disconnect`: отключение
  - `join`: присоединение пользователя к своим каналам

### OS-2: Аутентификация пользователей
- **Описание**: Идентификация пользователей по userId из сессии
- **Требования**: userId обязателен для всех операций

### OS-3: Обработка ошибок
- **Описание**: Корректная обработка ошибок подключения и передачи данных
- **Fallback**: API вызовы при недоступности socket

### OS-4: Масштабируемость
- **Описание**: Поддержка множественных одновременных подключений
- **Производительность**: Оптимизация для большого количества пользователей

## Требования к серверу Socket.IO

### SS-1: Обработка подключений
- Присоединение пользователей к персональным каналам
- Управление состоянием подключения

### SS-2: Маршрутизация сообщений
- Отправка сообщений конкретным получателям
- Broadcast уведомлений пользователям

### SS-3: Хранение состояния
- Кеширование данных комнат и сообщений
- Синхронизация с базой данных

### SS-4: Rate Limiting
- Проверка лимитов перед отправкой сообщений
- Управление блокировками пользователей

## Интеграционные требования

### IR-1: Синхронизация с Redux
- Обновление состояния Redux при получении данных через socket
- Поддержка существующей архитектуры состояния

### IR-2: Fallback на API
- API вызовы при недоступности socket
- Синхронизация состояния между socket и API

### IR-3: Обработка переподключений
- Восстановление состояния после переподключения
- Повторная загрузка данных при необходимости
