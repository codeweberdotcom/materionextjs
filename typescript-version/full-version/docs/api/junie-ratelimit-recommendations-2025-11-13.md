# Рекомендации Junie RateLimit

Дата: 2025-11-13 03:40

## Обзор
Проведён аудит подсистемы ограничения частоты запросов (rate limiting).
Рассмотрены:
- Сервис: `src/lib/rate-limit.ts` (конфиги, проверка, события, статистика, сброс/очистка)
- Типы: `src/lib/rate-limit/types.ts`
- Хранилища: `src/lib/rate-limit/stores` — Prisma (`prisma-store.ts`), Redis (`redis-store.ts`), фабрика (`index.ts`)
- Socket middleware: `src/lib/sockets/middleware/rateLimit.ts`
- API (админ): `src/app/api/admin/rate-limits/*`; примеры использования в `chat/ads`

## Критические риски
1) Окно «без лимитов» при старте процесса
- `RateLimitService` в конструкторе вызывает `loadConfigs()` без ожидания; до загрузки из БД `checkLimit()` при отсутствии конфига для модуля возвращает `allowed: true`.
- Риск: на холодном старте лимиты фактически не применяются (если модуль не закрыт дефолтами в памяти).
- Рекомендации:
  - Инициализировать карту конфигов синхронно дефолтами до первого запроса; асинхронную загрузку из БД применять только поверх (атомарной заменой Map).
  - Либо ленивую инициализацию при первом `checkLimit()` с флагом готовности.

2) Нет устойчивого fallback при сбоях Redis
- `RedisRateLimitStore.consume()` пытается подключаться внутри `ensureConnected()` и выбрасывает исключение при ошибке.
- В `RateLimitService.checkLimit()` исключение не перехватывается — клиент получает 500/ошибку сокета вместо деградации на Prisma.
- Рекомендации:
  - Оборачивать вызов `store.consume()` в `try/catch` и при ошибке динамически переключаться на `PrismaRateLimitStore` (лог + метрика/алерт), с обратной попыткой вернуть Redis позже.
  - В фабрике при старте выполнить предварительное подключение к Redis; при фейле — сразу выбирать Prisma.

3) Гонки (race conditions) в PrismaStore
- Текущая логика: `getOrCreateState` → расчёт → `updateState`. Параллельные запросы могут увидеть один и тот же `count` и оба пройти.
- Рекомендации:
  - Вариант A (предпочтительно): Redis как основной стор (атомарность через `INCR` + TTL), Prisma — как источник состояния/админки.
  - Вариант B (если нужен Prisma-first): в транзакции использовать `update` с `count: { increment: 1 }`, определять превышение по возвращённому значению; повторять при конфликте; по возможности добавлять условные обновления.

4) Всплеск событий (warning/block)
- При низком `warnThreshold` возможно большое число записей событий warning на горячих ключах.
- Рекомендации: дедуплицировать/троттлить события (не чаще 1 warning на ключ/окно; записывать только первый block per window).

## Важные замечания
5) Семантика блокировок по нескольким атрибутам (userId/email/ip)
- В `checkLimit()` блокировка наступает, если выполнено любое из условий по OR (userId, email, ip, ключ). Это может неожиданно блокировать «чистого» userId из-за IP/email.
- Рекомендации: сделать стратегию модульно настраиваемой (например, `auth` — сильнее по IP; `chat` — по userId), и явно документировать.

6) Дефолты для модулей
- В `setDefaultConfigs()` описаны `chat`, `ads`, `upload`, `auth`, `email`. Неизвестные модули без записей в БД могут остаться без лимитов.
- Рекомендации: поддерживать явный перечень модулей с дефолтами либо считать обращение к неизвестному модулю ошибкой конфигурации.

7) Нагрузка на статистику `getStats()`
- Для `chat` идёт `message.count()` за последнее окно. Нужны соответствующие индексы по `createdAt`.
- Рекомендации: убедиться в наличии индексов; при больших объёмах рассмотреть материализацию/агрегаты или метрики Redis.

8) Пагинация смешанных списков в `listStates()`
- `nextCursor` вычисляется по `RateLimitState`, но в выдачу добавляются «manualOnlyEntries`. Итоговая пагинация может вести к повторам/пропускам.
- Рекомендации: разделить источники (state/manual) или ввести единое представление с унифицированным курсором.

9) Кардинальность ключей (IP)
- Для публичных эндпоинтов на IP может расти объём ключей/состояний.
- Рекомендации: нормализация (CIDR), анонимные ключи, ограниченный TTL для старых состояний в Prisma.

10) PII в событиях и логах
- Хранится `email`, `ipAddress`. Проверьте соответствие политике приватности; возможно, достаточно `userId` с джоином по требованию.

11) Поведение в режиме `monitor`
- Превышения проходят, генерируя события; важно, чтобы клиенты/админы корректно трактовали различия между warning и «квази-блоком». Нужны пояснения в документации.

## Небольшие замечания
- ESLint: в `getStats()` заменить `let blockedCount = activeStates` на `const` (косметика).
- `redis-store.ts`: импорт `ioredis` помечен как нерешаемый — проверить зависимость в `package.json` и tsconfig path.
- `src/app/api/ads/route.ts`: после `const { user } = await requireAuth(request)` проверяется `session?.user` — переменной `session` нет; должна быть проверка `if (!user)`.

## Что реализовано хорошо
- Чёткое разделение политики (`RateLimitService`) и хранилища (Prisma/Redis).
- Наличие режима `monitor`, `warnThreshold`, событий, админ-операций.
- Socket middleware с предупреждениями/событиями превышения и корректным `Retry-After`.

## Приоритизация действий
1) Исключить «окно без лимитов» и добавить устойчивый fallback Redis→Prisma.
2) Сделать атомарность инкремента в PrismaStore (или Redis first).
3) Дедупликация событий warning/block.
4) Привести пагинацию смешанных списков к консистентной модели.
5) Проверить и добавить индексы для таблиц, задействованных в статистике и состояниях.
6) Задокументировать и при необходимости сконфигурировать политику блокировок по атрибутам.

## Вопросы для уточнения
- Планируется ли Redis как основной стор в продакшне? Есть ли healthchecks и fallback сценарии?
- Нужно ли хранение email в событиях, или достаточно `userId`?
- Будут ли новые модули RL помимо `chat`, `ads`, `upload`, `auth`, `email` — нужны ли дефолты заранее?
